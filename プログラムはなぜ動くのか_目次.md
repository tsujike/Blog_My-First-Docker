# 「プログラムはなぜ動くのか」目次

## 目次

- [「プログラムはなぜ動くのか」目次](#プログラムはなぜ動くのか目次)
  - [目次](#目次)
  - [第1章 プログラマにとってCPUとはなにか](#第1章-プログラマにとってcpuとはなにか)
  - [第2章 データを2進数でイメージしよう](#第2章-データを2進数でイメージしよう)
  - [第3章 コンピュータが小数点数の計算を間違える理由](#第3章-コンピュータが小数点数の計算を間違える理由)
  - [第4章 四角いメモリーを丸く使う](#第4章-四角いメモリーを丸く使う)
  - [第5章 メモリーとディスクの親密な関係](#第5章-メモリーとディスクの親密な関係)
  - [第6章 自分でデータを圧縮してみよう](#第6章-自分でデータを圧縮してみよう)
  - [第7章 プログラムはどんな環境で動くのか](#第7章-プログラムはどんな環境で動くのか)
  - [第8章 ソース・ファイルから実行可能ファイルができるまで](#第8章-ソースファイルから実行可能ファイルができるまで)
  - [第9章 OSとアプリケーションの関係](#第9章-osとアプリケーションの関係)
  - [第10章 アセンブリ言語からプログラムの本当の姿を知る](#第10章-アセンブリ言語からプログラムの本当の姿を知る)
  - [第11章 ハードウエアを制御する方法](#第11章-ハードウエアを制御する方法)
  - [第12章 コンピュータに「考え」させるためには](#第12章-コンピュータに考えさせるためには)
  - [補章 レッツ・トライ C言語!](#補章-レッツトライ-c言語)
  - [おわりに](#おわりに)
  - [索引](#索引)

---

## 第1章 プログラマにとってCPUとはなにか

- CPUの中身をのぞいてみよう - Page 13
- CPUはレジスタの集合体 - Page 16
- プログラムの流れを決めるプログラム・カウンタ - Page 19
- 条件分岐と繰り返しの仕組み - Page 21
- 関数呼び出しの仕組み - Page 24
- ベースとインデックスで配列を実現する - Page 27
- CPUにできることは、いたって単純 - Page 28

## 第2章 データを2進数でイメージしよう

- コンピュータが情報を2進数で取り扱う理由 - Page 33
- ところで2進数とは? - Page 35
- シフト演算と乗除算の関係 - Page 37
- コンピュータ処理に都合のいい「補数」 - Page 40
- 論理右シフトと算術右シフトの違い - Page 44
- 論理演算をマスターするコツ - Page 47

**COLUMN: あなたなら、どんなふうに説明しますか?**
- ピカピカの小学生にCPUと2進数を説明する - Page 50

## 第3章 コンピュータが小数点数の計算を間違える理由

- 0.1を100回加えても10にならない - Page 55
- 小数点数を2進数で表すには - Page 56
- コンピュータが計算を間違う理由 - Page 58
- 浮動小数点数とは - Page 59

## 第4章 四角いメモリーを丸く使う

- メモリーの物理的な仕組みはシンプル
- メモリーの論理的なイメージはビルディング
- ポインタなんて簡単だ
- メモリーを工夫して使うための基本は配列だ
- スタックとキュー、さらにリング・バッファ
- リストは要素の追加や削除が容易
- 2分探索木は効率的にデータを探せる

## 第5章 メモリーとディスクの親密な関係

- メモリーに読み出さないと実行できない
- ディスク・アクセスを高速化する「ディスク・キャッシュ」
- ディスクをメモリーの一部として使う「仮想記憶」
- メモリーを節約するプログラミング手法
- ディスクの物理構造も見ておこう

## 第6章 自分でデータを圧縮してみよう

- ファイルにはバイト単位で記録する
- ランレングス法の仕組み
- ランレングス法の欠点
- モールス符号にハフマン法の基礎を見た
- ハフマン符号は木を用いて作る
- ハフマン法で圧縮率が大幅に向上
- 可逆圧縮と非可逆圧縮 - Page 126

**COLUMN: あなたなら、どんなふうに説明しますか?**
- ゲームに夢中な中学生にメモリとディスクを説明する - Page 130

## 第7章 プログラムはどんな環境で動くのか

- 動作環境 = OS + ハードウエア - Page 135
- CPU以外の違いを乗り越えたWindows - Page 138
- APIはOSごとに違う - Page 140
- ソースコードを簡単に利用できるFreeBSDのPorts - Page 142
- エミュレータを使えば別の環境が手に入る - Page 143
- どこでも同じ実行環境を提供するJava仮想マシン - Page 144
- BIOSとブート・ストラップ - Page 146

## 第8章 ソース・ファイルから実行可能ファイルができるまで

- コンピュータはネイティブ・コードしか実行できない - Page 151
- ネイティブ・コードの内容を見てみよう - Page 154
- ソースコードを翻訳するのがコンパイラ - Page 155
- コンパイルだけでは実行可能ファイルが得られない - Page 157
- スタートアップとライブラリ・ファイル - Page 159
- DLLファイルとインポート・ライブラリ - Page 162
- 実行可能ファイルの実行に必要なことは? - Page 164
- ロード時に作られるスタックとヒープ - Page 165
- ちょっと高度なQ&A - Page 167

## 第9章 OSとアプリケーションの関係

- 歴史に見るOSの機能 - Page 173
- OSの存在を意識しよう - Page 175
- システム・コールと高水準言語の移植性 - Page 178
- OSと高水準言語がハードウエアを抽象化してくれる - Page 180
- WindowsというOSの特徴 - Page 182

**COLUMN: あなたなら、どんなふうに説明しますか?**
- 携帯電話が大好きな女子高生にOSの役割を説明する - Page 190

## 第10章 アセンブリ言語からプログラムの本当の姿を知る

- アセンブリ言語はネイティブ・コードと1対1に対応 - Page 193/194
- コンパイラでアセンブリ言語のソースコードを出力 - Page 197
- ネイティブ・コードに変換されない「擬似命令」 - Page 200
- アセンブリ言語の構文は「オペコード+オペランド」 - Page 203
- 最もよく使われるmov命令 - Page 205
- スタックへのプッシュとポップ - Page 206
- 関数呼び出しの仕組み - Page 208
- 関数の内部で行われる処理 - Page 211
- グローバル変数のための領域は常に確保されている - Page 213
- ローカル変数のための領域は一時的に確保される - Page 218
- 繰り返し処理の実現方法 - Page 221
- 条件分岐の実現方法 - Page 225
- プログラムの生の動きを知らなければわからないことがある - Page 227

## 第11章 ハードウエアを制御する方法

- アプリケーションはハードウエアと無関係? - Page 231
- ハードウエアとの入出力を支えるのはIN命令とOUT命令 - Page 235/236
- 入出力の実験プログラムを作ってみよう - Page 238/239
- 周辺装置が割り込みを要求する - Page 241/242
- 割り込みでリアルタイムな処理が実現する - Page 244
- 大量のデータを短時間に転送できるDMA - Page 245
- 文字やグラフィックスが表示される仕組み - Page 247

**COLUMN: あなたなら、どんなふうに説明しますか?**
- 近所のおばあちゃんにディスプレイとテレビの違いを説明する - Page 250

## 第12章 コンピュータに「考え」させるためには

- 「道具」としてのプログラムと「考え」るためのプログラム - Page 255
- 人間の考え方をプログラムで表す - Page 256
- 人間の癖をプログラムで表す - Page 259
- プログラミングに乱数を生かす方法 - Page 261
- 記憶を生かすことで、より人間らしい判断を行う - Page 263
- 思考パターンをプログラムで表す - Page 267

**COLUMN: あなたなら、どんなふうに説明しますか?**
- 行きつけの居酒屋のマスターにコンピュータが考える仕組みを説明する - Page 270

## 補章 レッツ・トライ C言語!

- Page 273

## おわりに

- Page 286

## 索引

- Page 287

