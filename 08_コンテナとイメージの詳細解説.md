# 【Docker詳細】コンテナとイメージを深く理解しよう

どうも、ケニー（tsujikenzo）です。今回は、**コンテナとイメージ**について、より深く解説します。

Docker公式ドキュメントの内容を基に、コンテナとイメージの本質を理解していきましょう。

## コンテナとは何か？

### コンテナの定義

簡単に言えば、**コンテナ（container）とはマシン上でサンドボックス化したプロセス**であり、ホストマシン上にある他すべてのプロセスから**隔離（isolate）**されています。

### コンテナの本質

コンテナは、**イメージの実行可能な実体（インスタンス）**です。

**コンテナについてまとめると：**
- イメージの実行可能な実体（インスタンス）
- Docker APIやCLIを使い、コンテナの作成、開始、停止、移動、削除ができます
- ローカルマシン上や仮想マシン上で実行できるのに加え、クラウドにもデプロイできます
- 可搬性（ポータビリティ）があります（多くのOSで実行できます）
- コンテナはお互いに隔離され、実行にはそれぞれが自身のソフトウェア、バイナリ、設定を使います

## コンテナの技術的な仕組み

### 名前空間（Namespaces）とcgroup

コンテナの隔離は、**カーネルの名前空間（namespaces）とcgroup**の活用によって実現されています。これらは長らくLinuxに存在する機能です。Dockerはこれらの能力を、分かりやすく簡単に使えるようにしています。

#### Namespaces（名前空間）

名前空間は、プロセスやリソースを隔離するためのLinuxカーネルの機能です。

**主な名前空間の種類：**

1. **PID名前空間（Process ID Namespace）**
   - プロセスIDの隔離
   - コンテナ内では、プロセスIDが1から始まる独立した番号体系を持つ

2. **ネットワーク名前空間（Network Namespace）**
   - ネットワークインターフェースの隔離
   - 各コンテナが独立したネットワークスタックを持つ

3. **マウント名前空間（Mount Namespace）**
   - ファイルシステムの隔離
   - 各コンテナが独立したファイルシステムツリーを持つ

4. **UTS名前空間（UTS Namespace）**
   - ホスト名とドメイン名の隔離
   - 各コンテナが独立したホスト名を持つ

5. **IPC名前空間（IPC Namespace）**
   - プロセス間通信（共有メモリ、セマフォなど）の隔離

6. **ユーザー名前空間（User Namespace）**
   - ユーザーIDとグループIDの隔離
   - コンテナ内のrootユーザーが、ホスト上では非特権ユーザーになる

#### cgroup（Control Groups）

cgroupは、プロセスグループのリソース使用量を制限・監視する機能です。

**cgroupの役割：**
- **CPU使用量の制限**：コンテナが使用できるCPU時間を制限
- **メモリ使用量の制限**：コンテナが使用できるメモリ量を制限
- **ディスクI/Oの制限**：ディスクへの読み書き速度を制限
- **リソース使用量の監視**：実際の使用量を監視

### chrootとの関係

**chrootを熟知していれば、コンテナとはchrootの拡張バージョンと考えてみましょう。**

- ファイルシステムとは、単にイメージから由来します
- ただし、コンテナの場合は、単純なchrootの使用ではできない付加的な隔離を追加します

**chrootとの違い：**
- **chroot**：ファイルシステムのルートディレクトリを変更するだけ
- **コンテナ**：ファイルシステムの隔離に加えて、プロセス、ネットワーク、リソースなども隔離

## コンテナイメージとは何か？

### イメージの定義

コンテナを実行したら、コンテナは**隔離されたファイルシステム**を使います。この特別なファイルシステムは**コンテナイメージ（container image）**によって提供されます。

### イメージに含まれるもの

イメージにはコンテナのファイルシステムが含まれており、**アプリケーションの実行に必要な全てを含む必要があります**。

**具体的には：**

#### 1. 依存関係
- アプリケーションを実行するために必要なパッケージ
- ライブラリ
- ランタイム環境

#### 2. 設定ファイル
- アプリケーションの設定
- システム設定

#### 3. スクリプト
- 起動スクリプト
- 初期化スクリプト

#### 4. バイナリ
- 実行ファイル
- アプリケーション本体

#### 5. その他の設定
- **環境変数**：デフォルトの環境変数
- **デフォルトコマンド**：コンテナ起動時に実行するコマンド
- **メタデータ**：その他の設定情報

### イメージの特徴

#### 読み取り専用
- イメージ自体は変更できない
- 複数のコンテナで同じイメージを共有できる

#### 階層構造（レイヤー）
- イメージは複数のレイヤーで構成されている
- Dockerfileの各命令ごとにレイヤーが生成される
- Dockerfileの内容を書き換えたことでイメージが再構築されるときには、変更がかかったレイヤーのみが再生成される
- レイヤーを共有することで、ディスク容量を節約できる
- 他の仮想化技術に比べてDockerイメージが軽量、小さい、早いを実現できているのも、このレイヤー構造があるからです

## イメージとコンテナの関係

### イメージからコンテナへ

```
イメージ（読み取り専用）
    ↓ docker run
コンテナ（読み書き可能なレイヤーが追加される）
```

### ファイルシステムの構造

```
┌─────────────────────────────────┐
│  読み書き可能なレイヤー          │ ← コンテナ固有
│  （コンテナ内での変更）           │
└──────────────┬──────────────────┘
               │
┌──────────────┴──────────────────┐
│  イメージ（読み取り専用）        │ ← 共有される
│  - レイヤー1                    │
│  - レイヤー2                    │
│  - レイヤー3                    │
└─────────────────────────────────┘
```

**重要なポイント：**
- イメージは読み取り専用で、変更できない
- コンテナは、イメージの上に読み書き可能なレイヤーを追加する
- コンテナ内でファイルを変更しても、イメージは変更されない
- コンテナを削除すると、読み書き可能なレイヤーも削除される

## 具体例で理解する

### 例：nginxコンテナ

#### ステップ1：イメージを取得

```bash
docker pull nginx:latest
```

**イメージに含まれるもの：**
- nginxのバイナリ
- nginxの設定ファイル
- 必要なライブラリ
- デフォルトのHTMLファイル
- 起動コマンド（nginx）

#### ステップ2：コンテナを作成・起動

```bash
docker run -d -p 8080:80 nginx
```

**何が起こるか：**
1. nginxイメージからコンテナが作成される
2. イメージの読み取り専用レイヤーがマウントされる
3. その上に読み書き可能なレイヤーが追加される
4. コンテナが起動し、nginxプロセスが実行される
5. コンテナ内でファイルを変更できる（ただし、イメージは変更されない）

#### ステップ3：コンテナ内でファイルを変更

```bash
docker exec -it <container_id> bash
echo "Hello Docker" > /usr/share/nginx/html/test.txt
```

**何が起こるか：**
- 読み書き可能なレイヤーに`test.txt`が作成される
- イメージの読み取り専用レイヤーは変更されない
- 他のコンテナには影響しない

#### ステップ4：コンテナを削除

```bash
docker rm -f <container_id>
```

**何が起こるか：**
- コンテナが削除される
- 読み書き可能なレイヤーも削除される
- `test.txt`ファイルも削除される
- イメージは残る（変更されていない）

## よくある質問

### Q1: コンテナとプロセスの違いは？

**A:** コンテナは、**サンドボックス化したプロセス**です。通常のプロセスと異なり、名前空間とcgroupによって隔離されています。これにより、他のプロセスやコンテナに影響を与えずに動作できます。

### Q2: イメージを変更すると、既存のコンテナに影響はありますか？

**A:** いいえ、影響ありません。イメージは読み取り専用なので、変更できません。新しいイメージを作成する場合は、新しいイメージとして扱われます。

### Q3: コンテナ内でファイルを変更すると、イメージに反映されますか？

**A:** いいえ、反映されません。コンテナ内での変更は、読み書き可能なレイヤーに保存されるだけで、イメージは変更されません。

### Q4: 同じイメージから複数のコンテナを作成した場合、ディスク容量は？

**A:** イメージのレイヤーは共有されるため、追加のディスク容量はほとんどかかりません。各コンテナの読み書き可能なレイヤーのみが追加されます。

### Q5: コンテナを削除しても、イメージは残りますか？

**A:** はい、残ります。イメージとコンテナは別物です。コンテナを削除しても、イメージは削除されません。

## まとめ

- **コンテナ**：マシン上でサンドボックス化したプロセス。イメージの実行可能な実体（インスタンス）
- **コンテナの隔離**：名前空間（namespaces）とcgroupによって実現される
- **イメージ**：コンテナのファイルシステムを提供する読み取り専用のテンプレート
- **イメージに含まれるもの**：アプリケーションの実行に必要な全て（依存関係、設定ファイル、スクリプト、バイナリ、環境変数、デフォルトコマンド、メタデータ）
- **イメージの特徴**：読み取り専用、階層構造（レイヤー）、再利用可能
- **イメージとコンテナの関係**：イメージは読み取り専用、コンテナは読み書き可能なレイヤーが追加される

コンテナとイメージの本質を理解することで、Dockerをより効果的に使えるようになります！

---

**参考リンク**
- [Docker公式ドキュメント（日本語）](https://docs.docker.jp/)
- [コンテナとは何？イメージとは何？（公式）](https://docs.docker.jp/get-started/what-is-a-container/)

